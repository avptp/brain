package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"

	"entgo.io/contrib/entgql"
	"github.com/alexedwards/argon2id"
	"github.com/avptp/brain/internal/api/arguments"
	"github.com/avptp/brain/internal/api/reporting"
	"github.com/avptp/brain/internal/auth"
	"github.com/avptp/brain/internal/generated/api"
	"github.com/avptp/brain/internal/generated/data"
	"github.com/avptp/brain/internal/generated/data/person"
	"github.com/avptp/brain/internal/generated/data/privacy"
	"github.com/avptp/brain/internal/transport/request"
	"github.com/google/uuid"
)

// CreatePerson is the resolver for the createPerson field.
func (r *mutationResolver) CreatePerson(ctx context.Context, input api.CreatePersonInput) (*api.CreatePersonPayload, error) {
	if !auth.Captcha(ctx, input.Captcha) {
		return nil, reporting.ErrCaptcha
	}

	d := data.FromContext(ctx) // transactional data client for mutations
	allowCtx := privacy.DecisionContext(ctx, privacy.Allow)

	p, err := d.Person.
		Create().
		SetEmail(input.Email).
		SetPassword(input.Password).
		SetTaxID(input.TaxID).
		SetFirstName(input.FirstName).
		SetNillableLastName(input.LastName).
		SetLanguage(input.Language).
		Save(allowCtx)

	if err != nil {
		return nil, err
	}

	return &api.CreatePersonPayload{
		Person: p,
	}, nil
}

// UpdatePerson is the resolver for the updatePerson field.
func (r *mutationResolver) UpdatePerson(ctx context.Context, input api.UpdatePersonInput) (*api.UpdatePersonPayload, error) {
	d := data.FromContext(ctx) // transactional data client for mutations
	update := d.Person.UpdateOneID(input.ID)

	// This is not clean, but it is an option until "gqlgen" makes it
	// possible to distinguish between undefined and null fields.
	// See: https://github.com/99designs/gqlgen/issues/1416
	fields := arguments.GetFields(ctx, "input")

	for _, key := range fields {
		switch key {
		case "email":
			if v := input.Email; v != nil {
				update.SetEmail(*v)
			}
		case "phone":
			if v := input.Phone; v != nil {
				update.SetPhone(*v)
			} else {
				update.ClearPhone()
			}
		case "taxId":
			if v := input.TaxID; v != nil {
				update.SetTaxID(*v)
			}
		case "firstName":
			if v := input.FirstName; v != nil {
				update.SetFirstName(*v)
			}
		case "lastName":
			if v := input.LastName; v != nil {
				update.SetLastName(*v)
			} else {
				update.ClearLastName()
			}
		case "language":
			if v := input.Language; v != nil {
				update.SetLanguage(*v)
			}
		case "birthdate":
			if v := input.Birthdate; v != nil {
				update.SetBirthdate(*v)
			} else {
				update.ClearBirthdate()
			}
		case "gender":
			if v := input.Gender; v != nil {
				update.SetGender(*v)
			} else {
				update.ClearGender()
			}
		case "address":
			if v := input.Address; v != nil {
				update.SetAddress(*v)
			} else {
				update.ClearAddress()
			}
		case "postalCode":
			if v := input.PostalCode; v != nil {
				update.SetPostalCode(*v)
			} else {
				update.ClearPostalCode()
			}
		case "city":
			if v := input.City; v != nil {
				update.SetCity(*v)
			} else {
				update.ClearCity()
			}
		case "country":
			if v := input.Country; v != nil {
				update.SetCountry(*v)
			} else {
				update.ClearCountry()
			}
		}
	}

	person, err := update.Save(ctx)

	if err != nil {
		return nil, err
	}

	return &api.UpdatePersonPayload{
		Person: person,
	}, nil
}

// UpdatePersonPassword is the resolver for the updatePersonPassword field.
func (r *mutationResolver) UpdatePersonPassword(ctx context.Context, input api.UpdatePersonPasswordInput) (*api.UpdatePersonPasswordPayload, error) {
	if !auth.Captcha(ctx, input.Captcha) {
		return nil, reporting.ErrCaptcha
	}

	d := data.FromContext(ctx) // transactional data client for mutations

	person, err := d.Person.
		Query().
		Where(person.IDEQ(input.ID)).
		First(ctx)

	if err != nil {
		return nil, reporting.ErrWrongPassword
	}

	match, err := argon2id.ComparePasswordAndHash(input.CurrentPassword, person.Password)

	if err != nil || !match {
		return nil, reporting.ErrWrongPassword
	}

	person, err = person.
		Update().
		SetPassword(input.NewPassword).
		Save(ctx)

	if err != nil {
		return nil, err
	}

	return &api.UpdatePersonPasswordPayload{
		Person: person,
	}, nil
}

// DeletePerson is the resolver for the deletePerson field.
func (r *mutationResolver) DeletePerson(ctx context.Context, input api.DeletePersonInput) (*api.DeletePersonPayload, error) {
	if !auth.Captcha(ctx, input.Captcha) {
		return nil, reporting.ErrCaptcha
	}

	d := data.FromContext(ctx) // transactional data client for mutations

	person, err := d.Person.
		Query().
		Where(person.IDEQ(input.ID)).
		First(ctx)

	if err != nil {
		return nil, reporting.ErrWrongPassword
	}

	match, err := argon2id.ComparePasswordAndHash(input.CurrentPassword, person.Password)

	if err != nil || !match {
		return nil, reporting.ErrWrongPassword
	}

	err = d.Person.
		DeleteOneID(input.ID).
		Exec(ctx)

	if err != nil {
		return nil, err
	}

	return &api.DeletePersonPayload{
		PersonID: input.ID,
	}, nil
}

// Authentications is the resolver for the authentications field.
func (r *personResolver) Authentications(ctx context.Context, obj *data.Person, after *entgql.Cursor[uuid.UUID], first *int, before *entgql.Cursor[uuid.UUID], last *int) (*data.AuthenticationConnection, error) {
	return obj.
		QueryAuthentications().
		Paginate(ctx, after, first, before, last)
}

// Viewer is the resolver for the viewer field.
func (r *queryResolver) Viewer(ctx context.Context) (*data.Person, error) {
	viewer := request.ViewerFromCtx(ctx)

	if viewer == nil {
		return nil, reporting.ErrUnauthenticated
	}

	return viewer, nil
}

// Person returns api.PersonResolver implementation.
func (r *Resolver) Person() api.PersonResolver { return &personResolver{r} }

type personResolver struct{ *Resolver }
