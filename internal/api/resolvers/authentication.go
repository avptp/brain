package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.62

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/alexedwards/argon2id"
	"github.com/avptp/brain/internal/api/reporting"
	"github.com/avptp/brain/internal/generated/api"
	"github.com/avptp/brain/internal/generated/data"
	"github.com/avptp/brain/internal/generated/data/authentication"
	"github.com/avptp/brain/internal/generated/data/person"
	"github.com/avptp/brain/internal/generated/data/privacy"
	"github.com/avptp/brain/internal/transport/request"
	redis_rate "github.com/go-redis/redis_rate/v10"
)

// CreateAuthentication is the resolver for the createAuthentication field.
func (r *mutationResolver) CreateAuthentication(ctx context.Context, input api.CreateAuthenticationInput) (*api.CreateAuthenticationPayload, error) {
	// Rate limit by normalized email
	// (to avoid exposing whether an email is in use)
	rlKey := fmt.Sprintf(
		"createAuthentication:%s",
		strings.ToLower(input.Email),
	)

	res, err := r.limiter.Allow(ctx, rlKey, redis_rate.PerHour(r.cfg.AuthenticationRateLimit))

	if err != nil {
		return nil, err
	}

	if res.Allowed <= 0 {
		return nil, reporting.ErrRateLimit
	}

	// Retrieve person by email
	// (it returns "wrong password" error to avoid exposing whether an email is in use)
	d := data.FromContext(ctx) // transactional data client for mutations
	allowCtx := privacy.DecisionContext(ctx, privacy.Allow)

	person, err := d.Person.
		Query().
		Where(person.EmailEQ(input.Email)).
		First(allowCtx)

	if err != nil {
		return nil, reporting.ErrWrongPassword
	}

	// Match the password
	match, err := argon2id.ComparePasswordAndHash(input.Password, person.Password)

	if err != nil || !match {
		return nil, reporting.ErrWrongPassword
	}

	// Create authentication and return its token
	ip := request.IPFromCtx(ctx)

	a, err := d.Authentication.
		Create().
		SetCreatedIP(ip).
		SetLastUsedIP(ip).
		SetPerson(person).
		Save(allowCtx)

	if err != nil {
		return nil, err
	}

	return &api.CreateAuthenticationPayload{
		Token: a.TokenEncoded(),
	}, nil
}

// PassAuthenticationPasswordChallenge is the resolver for the passAuthenticationPasswordChallenge field.
func (r *mutationResolver) PassAuthenticationPasswordChallenge(ctx context.Context, input api.PassAuthenticationPasswordChallengeInput) (*api.PassAuthenticationPasswordChallengePayload, error) {
	d := data.FromContext(ctx) // transactional data client for mutations

	// Retrieve authentication
	auth, err := d.
		Authentication.
		Query().
		Where(authentication.IDEQ(input.ID)).
		WithPerson().
		First(ctx)

	if err != nil {
		return nil, err
	}

	// Rate limit by person ID
	rlKey := fmt.Sprintf(
		"passAuthenticationPasswordChallenge:%s",
		auth.PersonID,
	)

	res, err := r.limiter.Allow(ctx, rlKey, redis_rate.PerHour(r.cfg.AuthenticationPasswordChallengeRateLimit))

	if err != nil {
		return nil, err
	}

	if res.Allowed <= 0 {
		return nil, reporting.ErrRateLimit
	}

	// Match the password
	match, err := argon2id.ComparePasswordAndHash(input.Password, auth.Edges.Person.Password)

	if err != nil || !match {
		return nil, reporting.ErrWrongPassword
	}

	// Create authentication and return its token
	_, err = auth.
		Update().
		SetLastPasswordChallengeAt(time.Now()).
		Save(ctx)

	if err != nil {
		return nil, err
	}

	return &api.PassAuthenticationPasswordChallengePayload{
		Success: true,
	}, nil
}

// PassAuthenticationCaptchaChallenge is the resolver for the passAuthenticationCaptchaChallenge field.
func (r *mutationResolver) PassAuthenticationCaptchaChallenge(ctx context.Context, input api.PassAuthenticationCaptchaChallengeInput) (*api.PassAuthenticationCaptchaChallengePayload, error) {
	d := data.FromContext(ctx) // transactional data client for mutations

	// Retrieve authentication
	auth, err := d.
		Authentication.
		Query().
		Where(authentication.IDEQ(input.ID)).
		First(ctx)

	if err != nil {
		return nil, err
	}

	// Rate limit by person ID
	rlKey := fmt.Sprintf(
		"passAuthenticationCaptchaChallenge:%s",
		auth.PersonID,
	)

	res, err := r.limiter.Allow(ctx, rlKey, redis_rate.PerHour(r.cfg.AuthenticationCaptchaChallengeRateLimit))

	if err != nil {
		return nil, err
	}

	if res.Allowed <= 0 {
		return nil, reporting.ErrRateLimit
	}

	// Verify captcha
	if !r.captcha.Verify(input.Captcha) {
		return nil, reporting.ErrCaptcha
	}

	// Create authentication and return its token
	_, err = auth.
		Update().
		SetLastCaptchaChallengeAt(time.Now()).
		Save(ctx)

	if err != nil {
		return nil, err
	}

	return &api.PassAuthenticationCaptchaChallengePayload{
		Success: true,
	}, nil
}

// DeleteAuthentication is the resolver for the deleteAuthentication field.
func (r *mutationResolver) DeleteAuthentication(ctx context.Context, input api.DeleteAuthenticationInput) (*api.DeleteAuthenticationPayload, error) {
	d := data.FromContext(ctx) // transactional data client for mutations

	err := d.Authentication.
		DeleteOneID(input.ID).
		Exec(ctx)

	if err != nil {
		return nil, err
	}

	return &api.DeleteAuthenticationPayload{
		AuthenticationID: input.ID,
	}, nil
}
