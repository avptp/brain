// Code generated by ent, DO NOT EDIT.

package data

import (
	"errors"
	"fmt"
	"time"

	"github.com/avptp/brain/internal/api/types"
	"github.com/avptp/brain/internal/generated/data/authentication"
	"github.com/avptp/brain/internal/generated/data/authorization"
	"github.com/avptp/brain/internal/generated/data/person"
	"github.com/avptp/brain/internal/generated/data/predicate"
)

// AuthenticationWhereInput represents a where input for filtering Authentication queries.
type AuthenticationWhereInput struct {
	Predicates []predicate.Authentication  `json:"-"`
	Not        *AuthenticationWhereInput   `json:"not,omitempty"`
	Or         []*AuthenticationWhereInput `json:"or,omitempty"`
	And        []*AuthenticationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *types.ID  `json:"id,omitempty"`
	IDNEQ   *types.ID  `json:"idNEQ,omitempty"`
	IDIn    []types.ID `json:"idIn,omitempty"`
	IDNotIn []types.ID `json:"idNotIn,omitempty"`
	IDGT    *types.ID  `json:"idGT,omitempty"`
	IDGTE   *types.ID  `json:"idGTE,omitempty"`
	IDLT    *types.ID  `json:"idLT,omitempty"`
	IDLTE   *types.ID  `json:"idLTE,omitempty"`

	// "person_id" field predicates.
	PersonID      *types.ID  `json:"personID,omitempty"`
	PersonIDNEQ   *types.ID  `json:"personIDNEQ,omitempty"`
	PersonIDIn    []types.ID `json:"personIDIn,omitempty"`
	PersonIDNotIn []types.ID `json:"personIDNotIn,omitempty"`

	// "created_ip" field predicates.
	CreatedIP             *string  `json:"createdIP,omitempty"`
	CreatedIPNEQ          *string  `json:"createdIPNEQ,omitempty"`
	CreatedIPIn           []string `json:"createdIPIn,omitempty"`
	CreatedIPNotIn        []string `json:"createdIPNotIn,omitempty"`
	CreatedIPGT           *string  `json:"createdIPGT,omitempty"`
	CreatedIPGTE          *string  `json:"createdIPGTE,omitempty"`
	CreatedIPLT           *string  `json:"createdIPLT,omitempty"`
	CreatedIPLTE          *string  `json:"createdIPLTE,omitempty"`
	CreatedIPContains     *string  `json:"createdIPContains,omitempty"`
	CreatedIPHasPrefix    *string  `json:"createdIPHasPrefix,omitempty"`
	CreatedIPHasSuffix    *string  `json:"createdIPHasSuffix,omitempty"`
	CreatedIPEqualFold    *string  `json:"createdIPEqualFold,omitempty"`
	CreatedIPContainsFold *string  `json:"createdIPContainsFold,omitempty"`

	// "last_used_ip" field predicates.
	LastUsedIP             *string  `json:"lastUsedIP,omitempty"`
	LastUsedIPNEQ          *string  `json:"lastUsedIPNEQ,omitempty"`
	LastUsedIPIn           []string `json:"lastUsedIPIn,omitempty"`
	LastUsedIPNotIn        []string `json:"lastUsedIPNotIn,omitempty"`
	LastUsedIPGT           *string  `json:"lastUsedIPGT,omitempty"`
	LastUsedIPGTE          *string  `json:"lastUsedIPGTE,omitempty"`
	LastUsedIPLT           *string  `json:"lastUsedIPLT,omitempty"`
	LastUsedIPLTE          *string  `json:"lastUsedIPLTE,omitempty"`
	LastUsedIPContains     *string  `json:"lastUsedIPContains,omitempty"`
	LastUsedIPHasPrefix    *string  `json:"lastUsedIPHasPrefix,omitempty"`
	LastUsedIPHasSuffix    *string  `json:"lastUsedIPHasSuffix,omitempty"`
	LastUsedIPEqualFold    *string  `json:"lastUsedIPEqualFold,omitempty"`
	LastUsedIPContainsFold *string  `json:"lastUsedIPContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_used_at" field predicates.
	LastUsedAt      *time.Time  `json:"lastUsedAt,omitempty"`
	LastUsedAtNEQ   *time.Time  `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn    []time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn []time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGT    *time.Time  `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGTE   *time.Time  `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLT    *time.Time  `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLTE   *time.Time  `json:"lastUsedAtLTE,omitempty"`

	// "last_password_challenge_at" field predicates.
	LastPasswordChallengeAt       *time.Time  `json:"lastPasswordChallengeAt,omitempty"`
	LastPasswordChallengeAtNEQ    *time.Time  `json:"lastPasswordChallengeAtNEQ,omitempty"`
	LastPasswordChallengeAtIn     []time.Time `json:"lastPasswordChallengeAtIn,omitempty"`
	LastPasswordChallengeAtNotIn  []time.Time `json:"lastPasswordChallengeAtNotIn,omitempty"`
	LastPasswordChallengeAtGT     *time.Time  `json:"lastPasswordChallengeAtGT,omitempty"`
	LastPasswordChallengeAtGTE    *time.Time  `json:"lastPasswordChallengeAtGTE,omitempty"`
	LastPasswordChallengeAtLT     *time.Time  `json:"lastPasswordChallengeAtLT,omitempty"`
	LastPasswordChallengeAtLTE    *time.Time  `json:"lastPasswordChallengeAtLTE,omitempty"`
	LastPasswordChallengeAtIsNil  bool        `json:"lastPasswordChallengeAtIsNil,omitempty"`
	LastPasswordChallengeAtNotNil bool        `json:"lastPasswordChallengeAtNotNil,omitempty"`

	// "last_captcha_challenge_at" field predicates.
	LastCaptchaChallengeAt       *time.Time  `json:"lastCaptchaChallengeAt,omitempty"`
	LastCaptchaChallengeAtNEQ    *time.Time  `json:"lastCaptchaChallengeAtNEQ,omitempty"`
	LastCaptchaChallengeAtIn     []time.Time `json:"lastCaptchaChallengeAtIn,omitempty"`
	LastCaptchaChallengeAtNotIn  []time.Time `json:"lastCaptchaChallengeAtNotIn,omitempty"`
	LastCaptchaChallengeAtGT     *time.Time  `json:"lastCaptchaChallengeAtGT,omitempty"`
	LastCaptchaChallengeAtGTE    *time.Time  `json:"lastCaptchaChallengeAtGTE,omitempty"`
	LastCaptchaChallengeAtLT     *time.Time  `json:"lastCaptchaChallengeAtLT,omitempty"`
	LastCaptchaChallengeAtLTE    *time.Time  `json:"lastCaptchaChallengeAtLTE,omitempty"`
	LastCaptchaChallengeAtIsNil  bool        `json:"lastCaptchaChallengeAtIsNil,omitempty"`
	LastCaptchaChallengeAtNotNil bool        `json:"lastCaptchaChallengeAtNotNil,omitempty"`

	// "person" edge predicates.
	HasPerson     *bool               `json:"hasPerson,omitempty"`
	HasPersonWith []*PersonWhereInput `json:"hasPersonWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AuthenticationWhereInput) AddPredicates(predicates ...predicate.Authentication) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AuthenticationWhereInput filter on the AuthenticationQuery builder.
func (i *AuthenticationWhereInput) Filter(q *AuthenticationQuery) (*AuthenticationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAuthenticationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAuthenticationWhereInput is returned in case the AuthenticationWhereInput is empty.
var ErrEmptyAuthenticationWhereInput = errors.New("data: empty predicate AuthenticationWhereInput")

// P returns a predicate for filtering authentications.
// An error is returned if the input is empty or invalid.
func (i *AuthenticationWhereInput) P() (predicate.Authentication, error) {
	var predicates []predicate.Authentication
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, authentication.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Authentication, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, authentication.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Authentication, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, authentication.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, authentication.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, authentication.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, authentication.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, authentication.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, authentication.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, authentication.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, authentication.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, authentication.IDLTE(*i.IDLTE))
	}
	if i.PersonID != nil {
		predicates = append(predicates, authentication.PersonIDEQ(*i.PersonID))
	}
	if i.PersonIDNEQ != nil {
		predicates = append(predicates, authentication.PersonIDNEQ(*i.PersonIDNEQ))
	}
	if len(i.PersonIDIn) > 0 {
		predicates = append(predicates, authentication.PersonIDIn(i.PersonIDIn...))
	}
	if len(i.PersonIDNotIn) > 0 {
		predicates = append(predicates, authentication.PersonIDNotIn(i.PersonIDNotIn...))
	}
	if i.CreatedIP != nil {
		predicates = append(predicates, authentication.CreatedIPEQ(*i.CreatedIP))
	}
	if i.CreatedIPNEQ != nil {
		predicates = append(predicates, authentication.CreatedIPNEQ(*i.CreatedIPNEQ))
	}
	if len(i.CreatedIPIn) > 0 {
		predicates = append(predicates, authentication.CreatedIPIn(i.CreatedIPIn...))
	}
	if len(i.CreatedIPNotIn) > 0 {
		predicates = append(predicates, authentication.CreatedIPNotIn(i.CreatedIPNotIn...))
	}
	if i.CreatedIPGT != nil {
		predicates = append(predicates, authentication.CreatedIPGT(*i.CreatedIPGT))
	}
	if i.CreatedIPGTE != nil {
		predicates = append(predicates, authentication.CreatedIPGTE(*i.CreatedIPGTE))
	}
	if i.CreatedIPLT != nil {
		predicates = append(predicates, authentication.CreatedIPLT(*i.CreatedIPLT))
	}
	if i.CreatedIPLTE != nil {
		predicates = append(predicates, authentication.CreatedIPLTE(*i.CreatedIPLTE))
	}
	if i.CreatedIPContains != nil {
		predicates = append(predicates, authentication.CreatedIPContains(*i.CreatedIPContains))
	}
	if i.CreatedIPHasPrefix != nil {
		predicates = append(predicates, authentication.CreatedIPHasPrefix(*i.CreatedIPHasPrefix))
	}
	if i.CreatedIPHasSuffix != nil {
		predicates = append(predicates, authentication.CreatedIPHasSuffix(*i.CreatedIPHasSuffix))
	}
	if i.CreatedIPEqualFold != nil {
		predicates = append(predicates, authentication.CreatedIPEqualFold(*i.CreatedIPEqualFold))
	}
	if i.CreatedIPContainsFold != nil {
		predicates = append(predicates, authentication.CreatedIPContainsFold(*i.CreatedIPContainsFold))
	}
	if i.LastUsedIP != nil {
		predicates = append(predicates, authentication.LastUsedIPEQ(*i.LastUsedIP))
	}
	if i.LastUsedIPNEQ != nil {
		predicates = append(predicates, authentication.LastUsedIPNEQ(*i.LastUsedIPNEQ))
	}
	if len(i.LastUsedIPIn) > 0 {
		predicates = append(predicates, authentication.LastUsedIPIn(i.LastUsedIPIn...))
	}
	if len(i.LastUsedIPNotIn) > 0 {
		predicates = append(predicates, authentication.LastUsedIPNotIn(i.LastUsedIPNotIn...))
	}
	if i.LastUsedIPGT != nil {
		predicates = append(predicates, authentication.LastUsedIPGT(*i.LastUsedIPGT))
	}
	if i.LastUsedIPGTE != nil {
		predicates = append(predicates, authentication.LastUsedIPGTE(*i.LastUsedIPGTE))
	}
	if i.LastUsedIPLT != nil {
		predicates = append(predicates, authentication.LastUsedIPLT(*i.LastUsedIPLT))
	}
	if i.LastUsedIPLTE != nil {
		predicates = append(predicates, authentication.LastUsedIPLTE(*i.LastUsedIPLTE))
	}
	if i.LastUsedIPContains != nil {
		predicates = append(predicates, authentication.LastUsedIPContains(*i.LastUsedIPContains))
	}
	if i.LastUsedIPHasPrefix != nil {
		predicates = append(predicates, authentication.LastUsedIPHasPrefix(*i.LastUsedIPHasPrefix))
	}
	if i.LastUsedIPHasSuffix != nil {
		predicates = append(predicates, authentication.LastUsedIPHasSuffix(*i.LastUsedIPHasSuffix))
	}
	if i.LastUsedIPEqualFold != nil {
		predicates = append(predicates, authentication.LastUsedIPEqualFold(*i.LastUsedIPEqualFold))
	}
	if i.LastUsedIPContainsFold != nil {
		predicates = append(predicates, authentication.LastUsedIPContainsFold(*i.LastUsedIPContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, authentication.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, authentication.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, authentication.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, authentication.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, authentication.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, authentication.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, authentication.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, authentication.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastUsedAt != nil {
		predicates = append(predicates, authentication.LastUsedAtEQ(*i.LastUsedAt))
	}
	if i.LastUsedAtNEQ != nil {
		predicates = append(predicates, authentication.LastUsedAtNEQ(*i.LastUsedAtNEQ))
	}
	if len(i.LastUsedAtIn) > 0 {
		predicates = append(predicates, authentication.LastUsedAtIn(i.LastUsedAtIn...))
	}
	if len(i.LastUsedAtNotIn) > 0 {
		predicates = append(predicates, authentication.LastUsedAtNotIn(i.LastUsedAtNotIn...))
	}
	if i.LastUsedAtGT != nil {
		predicates = append(predicates, authentication.LastUsedAtGT(*i.LastUsedAtGT))
	}
	if i.LastUsedAtGTE != nil {
		predicates = append(predicates, authentication.LastUsedAtGTE(*i.LastUsedAtGTE))
	}
	if i.LastUsedAtLT != nil {
		predicates = append(predicates, authentication.LastUsedAtLT(*i.LastUsedAtLT))
	}
	if i.LastUsedAtLTE != nil {
		predicates = append(predicates, authentication.LastUsedAtLTE(*i.LastUsedAtLTE))
	}
	if i.LastPasswordChallengeAt != nil {
		predicates = append(predicates, authentication.LastPasswordChallengeAtEQ(*i.LastPasswordChallengeAt))
	}
	if i.LastPasswordChallengeAtNEQ != nil {
		predicates = append(predicates, authentication.LastPasswordChallengeAtNEQ(*i.LastPasswordChallengeAtNEQ))
	}
	if len(i.LastPasswordChallengeAtIn) > 0 {
		predicates = append(predicates, authentication.LastPasswordChallengeAtIn(i.LastPasswordChallengeAtIn...))
	}
	if len(i.LastPasswordChallengeAtNotIn) > 0 {
		predicates = append(predicates, authentication.LastPasswordChallengeAtNotIn(i.LastPasswordChallengeAtNotIn...))
	}
	if i.LastPasswordChallengeAtGT != nil {
		predicates = append(predicates, authentication.LastPasswordChallengeAtGT(*i.LastPasswordChallengeAtGT))
	}
	if i.LastPasswordChallengeAtGTE != nil {
		predicates = append(predicates, authentication.LastPasswordChallengeAtGTE(*i.LastPasswordChallengeAtGTE))
	}
	if i.LastPasswordChallengeAtLT != nil {
		predicates = append(predicates, authentication.LastPasswordChallengeAtLT(*i.LastPasswordChallengeAtLT))
	}
	if i.LastPasswordChallengeAtLTE != nil {
		predicates = append(predicates, authentication.LastPasswordChallengeAtLTE(*i.LastPasswordChallengeAtLTE))
	}
	if i.LastPasswordChallengeAtIsNil {
		predicates = append(predicates, authentication.LastPasswordChallengeAtIsNil())
	}
	if i.LastPasswordChallengeAtNotNil {
		predicates = append(predicates, authentication.LastPasswordChallengeAtNotNil())
	}
	if i.LastCaptchaChallengeAt != nil {
		predicates = append(predicates, authentication.LastCaptchaChallengeAtEQ(*i.LastCaptchaChallengeAt))
	}
	if i.LastCaptchaChallengeAtNEQ != nil {
		predicates = append(predicates, authentication.LastCaptchaChallengeAtNEQ(*i.LastCaptchaChallengeAtNEQ))
	}
	if len(i.LastCaptchaChallengeAtIn) > 0 {
		predicates = append(predicates, authentication.LastCaptchaChallengeAtIn(i.LastCaptchaChallengeAtIn...))
	}
	if len(i.LastCaptchaChallengeAtNotIn) > 0 {
		predicates = append(predicates, authentication.LastCaptchaChallengeAtNotIn(i.LastCaptchaChallengeAtNotIn...))
	}
	if i.LastCaptchaChallengeAtGT != nil {
		predicates = append(predicates, authentication.LastCaptchaChallengeAtGT(*i.LastCaptchaChallengeAtGT))
	}
	if i.LastCaptchaChallengeAtGTE != nil {
		predicates = append(predicates, authentication.LastCaptchaChallengeAtGTE(*i.LastCaptchaChallengeAtGTE))
	}
	if i.LastCaptchaChallengeAtLT != nil {
		predicates = append(predicates, authentication.LastCaptchaChallengeAtLT(*i.LastCaptchaChallengeAtLT))
	}
	if i.LastCaptchaChallengeAtLTE != nil {
		predicates = append(predicates, authentication.LastCaptchaChallengeAtLTE(*i.LastCaptchaChallengeAtLTE))
	}
	if i.LastCaptchaChallengeAtIsNil {
		predicates = append(predicates, authentication.LastCaptchaChallengeAtIsNil())
	}
	if i.LastCaptchaChallengeAtNotNil {
		predicates = append(predicates, authentication.LastCaptchaChallengeAtNotNil())
	}

	if i.HasPerson != nil {
		p := authentication.HasPerson()
		if !*i.HasPerson {
			p = authentication.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPersonWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasPersonWith))
		for _, w := range i.HasPersonWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPersonWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, authentication.HasPersonWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAuthenticationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return authentication.And(predicates...), nil
	}
}

// AuthorizationWhereInput represents a where input for filtering Authorization queries.
type AuthorizationWhereInput struct {
	Predicates []predicate.Authorization  `json:"-"`
	Not        *AuthorizationWhereInput   `json:"not,omitempty"`
	Or         []*AuthorizationWhereInput `json:"or,omitempty"`
	And        []*AuthorizationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *types.ID  `json:"id,omitempty"`
	IDNEQ   *types.ID  `json:"idNEQ,omitempty"`
	IDIn    []types.ID `json:"idIn,omitempty"`
	IDNotIn []types.ID `json:"idNotIn,omitempty"`
	IDGT    *types.ID  `json:"idGT,omitempty"`
	IDGTE   *types.ID  `json:"idGTE,omitempty"`
	IDLT    *types.ID  `json:"idLT,omitempty"`
	IDLTE   *types.ID  `json:"idLTE,omitempty"`

	// "person_id" field predicates.
	PersonID      *types.ID  `json:"personID,omitempty"`
	PersonIDNEQ   *types.ID  `json:"personIDNEQ,omitempty"`
	PersonIDIn    []types.ID `json:"personIDIn,omitempty"`
	PersonIDNotIn []types.ID `json:"personIDNotIn,omitempty"`

	// "kind" field predicates.
	Kind      *authorization.Kind  `json:"kind,omitempty"`
	KindNEQ   *authorization.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []authorization.Kind `json:"kindIn,omitempty"`
	KindNotIn []authorization.Kind `json:"kindNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "person" edge predicates.
	HasPerson     *bool               `json:"hasPerson,omitempty"`
	HasPersonWith []*PersonWhereInput `json:"hasPersonWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AuthorizationWhereInput) AddPredicates(predicates ...predicate.Authorization) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AuthorizationWhereInput filter on the AuthorizationQuery builder.
func (i *AuthorizationWhereInput) Filter(q *AuthorizationQuery) (*AuthorizationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAuthorizationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAuthorizationWhereInput is returned in case the AuthorizationWhereInput is empty.
var ErrEmptyAuthorizationWhereInput = errors.New("data: empty predicate AuthorizationWhereInput")

// P returns a predicate for filtering authorizations.
// An error is returned if the input is empty or invalid.
func (i *AuthorizationWhereInput) P() (predicate.Authorization, error) {
	var predicates []predicate.Authorization
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, authorization.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Authorization, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, authorization.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Authorization, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, authorization.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, authorization.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, authorization.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, authorization.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, authorization.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, authorization.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, authorization.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, authorization.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, authorization.IDLTE(*i.IDLTE))
	}
	if i.PersonID != nil {
		predicates = append(predicates, authorization.PersonIDEQ(*i.PersonID))
	}
	if i.PersonIDNEQ != nil {
		predicates = append(predicates, authorization.PersonIDNEQ(*i.PersonIDNEQ))
	}
	if len(i.PersonIDIn) > 0 {
		predicates = append(predicates, authorization.PersonIDIn(i.PersonIDIn...))
	}
	if len(i.PersonIDNotIn) > 0 {
		predicates = append(predicates, authorization.PersonIDNotIn(i.PersonIDNotIn...))
	}
	if i.Kind != nil {
		predicates = append(predicates, authorization.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, authorization.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, authorization.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, authorization.KindNotIn(i.KindNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, authorization.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, authorization.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, authorization.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, authorization.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, authorization.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, authorization.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, authorization.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, authorization.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasPerson != nil {
		p := authorization.HasPerson()
		if !*i.HasPerson {
			p = authorization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPersonWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasPersonWith))
		for _, w := range i.HasPersonWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPersonWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, authorization.HasPersonWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAuthorizationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return authorization.And(predicates...), nil
	}
}

// PersonWhereInput represents a where input for filtering Person queries.
type PersonWhereInput struct {
	Predicates []predicate.Person  `json:"-"`
	Not        *PersonWhereInput   `json:"not,omitempty"`
	Or         []*PersonWhereInput `json:"or,omitempty"`
	And        []*PersonWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *types.ID  `json:"id,omitempty"`
	IDNEQ   *types.ID  `json:"idNEQ,omitempty"`
	IDIn    []types.ID `json:"idIn,omitempty"`
	IDNotIn []types.ID `json:"idNotIn,omitempty"`
	IDGT    *types.ID  `json:"idGT,omitempty"`
	IDGTE   *types.ID  `json:"idGTE,omitempty"`
	IDLT    *types.ID  `json:"idLT,omitempty"`
	IDLTE   *types.ID  `json:"idLTE,omitempty"`

	// "stripe_id" field predicates.
	StripeID             *string  `json:"stripeID,omitempty"`
	StripeIDNEQ          *string  `json:"stripeIDNEQ,omitempty"`
	StripeIDIn           []string `json:"stripeIDIn,omitempty"`
	StripeIDNotIn        []string `json:"stripeIDNotIn,omitempty"`
	StripeIDGT           *string  `json:"stripeIDGT,omitempty"`
	StripeIDGTE          *string  `json:"stripeIDGTE,omitempty"`
	StripeIDLT           *string  `json:"stripeIDLT,omitempty"`
	StripeIDLTE          *string  `json:"stripeIDLTE,omitempty"`
	StripeIDContains     *string  `json:"stripeIDContains,omitempty"`
	StripeIDHasPrefix    *string  `json:"stripeIDHasPrefix,omitempty"`
	StripeIDHasSuffix    *string  `json:"stripeIDHasSuffix,omitempty"`
	StripeIDIsNil        bool     `json:"stripeIDIsNil,omitempty"`
	StripeIDNotNil       bool     `json:"stripeIDNotNil,omitempty"`
	StripeIDEqualFold    *string  `json:"stripeIDEqualFold,omitempty"`
	StripeIDContainsFold *string  `json:"stripeIDContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "email_verified_at" field predicates.
	EmailVerifiedAt       *time.Time  `json:"emailVerifiedAt,omitempty"`
	EmailVerifiedAtNEQ    *time.Time  `json:"emailVerifiedAtNEQ,omitempty"`
	EmailVerifiedAtIn     []time.Time `json:"emailVerifiedAtIn,omitempty"`
	EmailVerifiedAtNotIn  []time.Time `json:"emailVerifiedAtNotIn,omitempty"`
	EmailVerifiedAtGT     *time.Time  `json:"emailVerifiedAtGT,omitempty"`
	EmailVerifiedAtGTE    *time.Time  `json:"emailVerifiedAtGTE,omitempty"`
	EmailVerifiedAtLT     *time.Time  `json:"emailVerifiedAtLT,omitempty"`
	EmailVerifiedAtLTE    *time.Time  `json:"emailVerifiedAtLTE,omitempty"`
	EmailVerifiedAtIsNil  bool        `json:"emailVerifiedAtIsNil,omitempty"`
	EmailVerifiedAtNotNil bool        `json:"emailVerifiedAtNotNil,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneIsNil        bool     `json:"phoneIsNil,omitempty"`
	PhoneNotNil       bool     `json:"phoneNotNil,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "tax_id" field predicates.
	TaxID             *string  `json:"taxID,omitempty"`
	TaxIDNEQ          *string  `json:"taxIDNEQ,omitempty"`
	TaxIDIn           []string `json:"taxIDIn,omitempty"`
	TaxIDNotIn        []string `json:"taxIDNotIn,omitempty"`
	TaxIDGT           *string  `json:"taxIDGT,omitempty"`
	TaxIDGTE          *string  `json:"taxIDGTE,omitempty"`
	TaxIDLT           *string  `json:"taxIDLT,omitempty"`
	TaxIDLTE          *string  `json:"taxIDLTE,omitempty"`
	TaxIDContains     *string  `json:"taxIDContains,omitempty"`
	TaxIDHasPrefix    *string  `json:"taxIDHasPrefix,omitempty"`
	TaxIDHasSuffix    *string  `json:"taxIDHasSuffix,omitempty"`
	TaxIDEqualFold    *string  `json:"taxIDEqualFold,omitempty"`
	TaxIDContainsFold *string  `json:"taxIDContainsFold,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        bool     `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       bool     `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "language" field predicates.
	Language             *string  `json:"language,omitempty"`
	LanguageNEQ          *string  `json:"languageNEQ,omitempty"`
	LanguageIn           []string `json:"languageIn,omitempty"`
	LanguageNotIn        []string `json:"languageNotIn,omitempty"`
	LanguageGT           *string  `json:"languageGT,omitempty"`
	LanguageGTE          *string  `json:"languageGTE,omitempty"`
	LanguageLT           *string  `json:"languageLT,omitempty"`
	LanguageLTE          *string  `json:"languageLTE,omitempty"`
	LanguageContains     *string  `json:"languageContains,omitempty"`
	LanguageHasPrefix    *string  `json:"languageHasPrefix,omitempty"`
	LanguageHasSuffix    *string  `json:"languageHasSuffix,omitempty"`
	LanguageEqualFold    *string  `json:"languageEqualFold,omitempty"`
	LanguageContainsFold *string  `json:"languageContainsFold,omitempty"`

	// "birthdate" field predicates.
	Birthdate       *time.Time  `json:"birthdate,omitempty"`
	BirthdateNEQ    *time.Time  `json:"birthdateNEQ,omitempty"`
	BirthdateIn     []time.Time `json:"birthdateIn,omitempty"`
	BirthdateNotIn  []time.Time `json:"birthdateNotIn,omitempty"`
	BirthdateGT     *time.Time  `json:"birthdateGT,omitempty"`
	BirthdateGTE    *time.Time  `json:"birthdateGTE,omitempty"`
	BirthdateLT     *time.Time  `json:"birthdateLT,omitempty"`
	BirthdateLTE    *time.Time  `json:"birthdateLTE,omitempty"`
	BirthdateIsNil  bool        `json:"birthdateIsNil,omitempty"`
	BirthdateNotNil bool        `json:"birthdateNotNil,omitempty"`

	// "gender" field predicates.
	Gender       *person.Gender  `json:"gender,omitempty"`
	GenderNEQ    *person.Gender  `json:"genderNEQ,omitempty"`
	GenderIn     []person.Gender `json:"genderIn,omitempty"`
	GenderNotIn  []person.Gender `json:"genderNotIn,omitempty"`
	GenderIsNil  bool            `json:"genderIsNil,omitempty"`
	GenderNotNil bool            `json:"genderNotNil,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "postal_code" field predicates.
	PostalCode             *string  `json:"postalCode,omitempty"`
	PostalCodeNEQ          *string  `json:"postalCodeNEQ,omitempty"`
	PostalCodeIn           []string `json:"postalCodeIn,omitempty"`
	PostalCodeNotIn        []string `json:"postalCodeNotIn,omitempty"`
	PostalCodeGT           *string  `json:"postalCodeGT,omitempty"`
	PostalCodeGTE          *string  `json:"postalCodeGTE,omitempty"`
	PostalCodeLT           *string  `json:"postalCodeLT,omitempty"`
	PostalCodeLTE          *string  `json:"postalCodeLTE,omitempty"`
	PostalCodeContains     *string  `json:"postalCodeContains,omitempty"`
	PostalCodeHasPrefix    *string  `json:"postalCodeHasPrefix,omitempty"`
	PostalCodeHasSuffix    *string  `json:"postalCodeHasSuffix,omitempty"`
	PostalCodeIsNil        bool     `json:"postalCodeIsNil,omitempty"`
	PostalCodeNotNil       bool     `json:"postalCodeNotNil,omitempty"`
	PostalCodeEqualFold    *string  `json:"postalCodeEqualFold,omitempty"`
	PostalCodeContainsFold *string  `json:"postalCodeContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityIsNil        bool     `json:"cityIsNil,omitempty"`
	CityNotNil       bool     `json:"cityNotNil,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryIsNil        bool     `json:"countryIsNil,omitempty"`
	CountryNotNil       bool     `json:"countryNotNil,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "subscribed" field predicates.
	Subscribed    *bool `json:"subscribed,omitempty"`
	SubscribedNEQ *bool `json:"subscribedNEQ,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "authentications" edge predicates.
	HasAuthentications     *bool                       `json:"hasAuthentications,omitempty"`
	HasAuthenticationsWith []*AuthenticationWhereInput `json:"hasAuthenticationsWith,omitempty"`

	// "authorizations" edge predicates.
	HasAuthorizations     *bool                      `json:"hasAuthorizations,omitempty"`
	HasAuthorizationsWith []*AuthorizationWhereInput `json:"hasAuthorizationsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PersonWhereInput) AddPredicates(predicates ...predicate.Person) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PersonWhereInput filter on the PersonQuery builder.
func (i *PersonWhereInput) Filter(q *PersonQuery) (*PersonQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPersonWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPersonWhereInput is returned in case the PersonWhereInput is empty.
var ErrEmptyPersonWhereInput = errors.New("data: empty predicate PersonWhereInput")

// P returns a predicate for filtering persons.
// An error is returned if the input is empty or invalid.
func (i *PersonWhereInput) P() (predicate.Person, error) {
	var predicates []predicate.Person
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, person.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Person, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, person.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Person, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, person.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, person.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, person.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, person.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, person.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, person.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, person.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, person.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, person.IDLTE(*i.IDLTE))
	}
	if i.StripeID != nil {
		predicates = append(predicates, person.StripeIDEQ(*i.StripeID))
	}
	if i.StripeIDNEQ != nil {
		predicates = append(predicates, person.StripeIDNEQ(*i.StripeIDNEQ))
	}
	if len(i.StripeIDIn) > 0 {
		predicates = append(predicates, person.StripeIDIn(i.StripeIDIn...))
	}
	if len(i.StripeIDNotIn) > 0 {
		predicates = append(predicates, person.StripeIDNotIn(i.StripeIDNotIn...))
	}
	if i.StripeIDGT != nil {
		predicates = append(predicates, person.StripeIDGT(*i.StripeIDGT))
	}
	if i.StripeIDGTE != nil {
		predicates = append(predicates, person.StripeIDGTE(*i.StripeIDGTE))
	}
	if i.StripeIDLT != nil {
		predicates = append(predicates, person.StripeIDLT(*i.StripeIDLT))
	}
	if i.StripeIDLTE != nil {
		predicates = append(predicates, person.StripeIDLTE(*i.StripeIDLTE))
	}
	if i.StripeIDContains != nil {
		predicates = append(predicates, person.StripeIDContains(*i.StripeIDContains))
	}
	if i.StripeIDHasPrefix != nil {
		predicates = append(predicates, person.StripeIDHasPrefix(*i.StripeIDHasPrefix))
	}
	if i.StripeIDHasSuffix != nil {
		predicates = append(predicates, person.StripeIDHasSuffix(*i.StripeIDHasSuffix))
	}
	if i.StripeIDIsNil {
		predicates = append(predicates, person.StripeIDIsNil())
	}
	if i.StripeIDNotNil {
		predicates = append(predicates, person.StripeIDNotNil())
	}
	if i.StripeIDEqualFold != nil {
		predicates = append(predicates, person.StripeIDEqualFold(*i.StripeIDEqualFold))
	}
	if i.StripeIDContainsFold != nil {
		predicates = append(predicates, person.StripeIDContainsFold(*i.StripeIDContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, person.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, person.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, person.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, person.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, person.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, person.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, person.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, person.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, person.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, person.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, person.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, person.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, person.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.EmailVerifiedAt != nil {
		predicates = append(predicates, person.EmailVerifiedAtEQ(*i.EmailVerifiedAt))
	}
	if i.EmailVerifiedAtNEQ != nil {
		predicates = append(predicates, person.EmailVerifiedAtNEQ(*i.EmailVerifiedAtNEQ))
	}
	if len(i.EmailVerifiedAtIn) > 0 {
		predicates = append(predicates, person.EmailVerifiedAtIn(i.EmailVerifiedAtIn...))
	}
	if len(i.EmailVerifiedAtNotIn) > 0 {
		predicates = append(predicates, person.EmailVerifiedAtNotIn(i.EmailVerifiedAtNotIn...))
	}
	if i.EmailVerifiedAtGT != nil {
		predicates = append(predicates, person.EmailVerifiedAtGT(*i.EmailVerifiedAtGT))
	}
	if i.EmailVerifiedAtGTE != nil {
		predicates = append(predicates, person.EmailVerifiedAtGTE(*i.EmailVerifiedAtGTE))
	}
	if i.EmailVerifiedAtLT != nil {
		predicates = append(predicates, person.EmailVerifiedAtLT(*i.EmailVerifiedAtLT))
	}
	if i.EmailVerifiedAtLTE != nil {
		predicates = append(predicates, person.EmailVerifiedAtLTE(*i.EmailVerifiedAtLTE))
	}
	if i.EmailVerifiedAtIsNil {
		predicates = append(predicates, person.EmailVerifiedAtIsNil())
	}
	if i.EmailVerifiedAtNotNil {
		predicates = append(predicates, person.EmailVerifiedAtNotNil())
	}
	if i.Phone != nil {
		predicates = append(predicates, person.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, person.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, person.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, person.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, person.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, person.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, person.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, person.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, person.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, person.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, person.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneIsNil {
		predicates = append(predicates, person.PhoneIsNil())
	}
	if i.PhoneNotNil {
		predicates = append(predicates, person.PhoneNotNil())
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, person.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, person.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, person.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, person.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, person.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, person.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, person.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, person.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, person.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, person.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, person.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, person.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, person.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, person.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, person.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.TaxID != nil {
		predicates = append(predicates, person.TaxIDEQ(*i.TaxID))
	}
	if i.TaxIDNEQ != nil {
		predicates = append(predicates, person.TaxIDNEQ(*i.TaxIDNEQ))
	}
	if len(i.TaxIDIn) > 0 {
		predicates = append(predicates, person.TaxIDIn(i.TaxIDIn...))
	}
	if len(i.TaxIDNotIn) > 0 {
		predicates = append(predicates, person.TaxIDNotIn(i.TaxIDNotIn...))
	}
	if i.TaxIDGT != nil {
		predicates = append(predicates, person.TaxIDGT(*i.TaxIDGT))
	}
	if i.TaxIDGTE != nil {
		predicates = append(predicates, person.TaxIDGTE(*i.TaxIDGTE))
	}
	if i.TaxIDLT != nil {
		predicates = append(predicates, person.TaxIDLT(*i.TaxIDLT))
	}
	if i.TaxIDLTE != nil {
		predicates = append(predicates, person.TaxIDLTE(*i.TaxIDLTE))
	}
	if i.TaxIDContains != nil {
		predicates = append(predicates, person.TaxIDContains(*i.TaxIDContains))
	}
	if i.TaxIDHasPrefix != nil {
		predicates = append(predicates, person.TaxIDHasPrefix(*i.TaxIDHasPrefix))
	}
	if i.TaxIDHasSuffix != nil {
		predicates = append(predicates, person.TaxIDHasSuffix(*i.TaxIDHasSuffix))
	}
	if i.TaxIDEqualFold != nil {
		predicates = append(predicates, person.TaxIDEqualFold(*i.TaxIDEqualFold))
	}
	if i.TaxIDContainsFold != nil {
		predicates = append(predicates, person.TaxIDContainsFold(*i.TaxIDContainsFold))
	}
	if i.FirstName != nil {
		predicates = append(predicates, person.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, person.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, person.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, person.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, person.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, person.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, person.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, person.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, person.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, person.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, person.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, person.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, person.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, person.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, person.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, person.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, person.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, person.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, person.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, person.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, person.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, person.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, person.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, person.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameIsNil {
		predicates = append(predicates, person.LastNameIsNil())
	}
	if i.LastNameNotNil {
		predicates = append(predicates, person.LastNameNotNil())
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, person.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, person.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.Language != nil {
		predicates = append(predicates, person.LanguageEQ(*i.Language))
	}
	if i.LanguageNEQ != nil {
		predicates = append(predicates, person.LanguageNEQ(*i.LanguageNEQ))
	}
	if len(i.LanguageIn) > 0 {
		predicates = append(predicates, person.LanguageIn(i.LanguageIn...))
	}
	if len(i.LanguageNotIn) > 0 {
		predicates = append(predicates, person.LanguageNotIn(i.LanguageNotIn...))
	}
	if i.LanguageGT != nil {
		predicates = append(predicates, person.LanguageGT(*i.LanguageGT))
	}
	if i.LanguageGTE != nil {
		predicates = append(predicates, person.LanguageGTE(*i.LanguageGTE))
	}
	if i.LanguageLT != nil {
		predicates = append(predicates, person.LanguageLT(*i.LanguageLT))
	}
	if i.LanguageLTE != nil {
		predicates = append(predicates, person.LanguageLTE(*i.LanguageLTE))
	}
	if i.LanguageContains != nil {
		predicates = append(predicates, person.LanguageContains(*i.LanguageContains))
	}
	if i.LanguageHasPrefix != nil {
		predicates = append(predicates, person.LanguageHasPrefix(*i.LanguageHasPrefix))
	}
	if i.LanguageHasSuffix != nil {
		predicates = append(predicates, person.LanguageHasSuffix(*i.LanguageHasSuffix))
	}
	if i.LanguageEqualFold != nil {
		predicates = append(predicates, person.LanguageEqualFold(*i.LanguageEqualFold))
	}
	if i.LanguageContainsFold != nil {
		predicates = append(predicates, person.LanguageContainsFold(*i.LanguageContainsFold))
	}
	if i.Birthdate != nil {
		predicates = append(predicates, person.BirthdateEQ(*i.Birthdate))
	}
	if i.BirthdateNEQ != nil {
		predicates = append(predicates, person.BirthdateNEQ(*i.BirthdateNEQ))
	}
	if len(i.BirthdateIn) > 0 {
		predicates = append(predicates, person.BirthdateIn(i.BirthdateIn...))
	}
	if len(i.BirthdateNotIn) > 0 {
		predicates = append(predicates, person.BirthdateNotIn(i.BirthdateNotIn...))
	}
	if i.BirthdateGT != nil {
		predicates = append(predicates, person.BirthdateGT(*i.BirthdateGT))
	}
	if i.BirthdateGTE != nil {
		predicates = append(predicates, person.BirthdateGTE(*i.BirthdateGTE))
	}
	if i.BirthdateLT != nil {
		predicates = append(predicates, person.BirthdateLT(*i.BirthdateLT))
	}
	if i.BirthdateLTE != nil {
		predicates = append(predicates, person.BirthdateLTE(*i.BirthdateLTE))
	}
	if i.BirthdateIsNil {
		predicates = append(predicates, person.BirthdateIsNil())
	}
	if i.BirthdateNotNil {
		predicates = append(predicates, person.BirthdateNotNil())
	}
	if i.Gender != nil {
		predicates = append(predicates, person.GenderEQ(*i.Gender))
	}
	if i.GenderNEQ != nil {
		predicates = append(predicates, person.GenderNEQ(*i.GenderNEQ))
	}
	if len(i.GenderIn) > 0 {
		predicates = append(predicates, person.GenderIn(i.GenderIn...))
	}
	if len(i.GenderNotIn) > 0 {
		predicates = append(predicates, person.GenderNotIn(i.GenderNotIn...))
	}
	if i.GenderIsNil {
		predicates = append(predicates, person.GenderIsNil())
	}
	if i.GenderNotNil {
		predicates = append(predicates, person.GenderNotNil())
	}
	if i.Address != nil {
		predicates = append(predicates, person.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, person.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, person.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, person.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, person.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, person.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, person.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, person.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, person.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, person.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, person.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, person.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, person.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, person.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, person.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.PostalCode != nil {
		predicates = append(predicates, person.PostalCodeEQ(*i.PostalCode))
	}
	if i.PostalCodeNEQ != nil {
		predicates = append(predicates, person.PostalCodeNEQ(*i.PostalCodeNEQ))
	}
	if len(i.PostalCodeIn) > 0 {
		predicates = append(predicates, person.PostalCodeIn(i.PostalCodeIn...))
	}
	if len(i.PostalCodeNotIn) > 0 {
		predicates = append(predicates, person.PostalCodeNotIn(i.PostalCodeNotIn...))
	}
	if i.PostalCodeGT != nil {
		predicates = append(predicates, person.PostalCodeGT(*i.PostalCodeGT))
	}
	if i.PostalCodeGTE != nil {
		predicates = append(predicates, person.PostalCodeGTE(*i.PostalCodeGTE))
	}
	if i.PostalCodeLT != nil {
		predicates = append(predicates, person.PostalCodeLT(*i.PostalCodeLT))
	}
	if i.PostalCodeLTE != nil {
		predicates = append(predicates, person.PostalCodeLTE(*i.PostalCodeLTE))
	}
	if i.PostalCodeContains != nil {
		predicates = append(predicates, person.PostalCodeContains(*i.PostalCodeContains))
	}
	if i.PostalCodeHasPrefix != nil {
		predicates = append(predicates, person.PostalCodeHasPrefix(*i.PostalCodeHasPrefix))
	}
	if i.PostalCodeHasSuffix != nil {
		predicates = append(predicates, person.PostalCodeHasSuffix(*i.PostalCodeHasSuffix))
	}
	if i.PostalCodeIsNil {
		predicates = append(predicates, person.PostalCodeIsNil())
	}
	if i.PostalCodeNotNil {
		predicates = append(predicates, person.PostalCodeNotNil())
	}
	if i.PostalCodeEqualFold != nil {
		predicates = append(predicates, person.PostalCodeEqualFold(*i.PostalCodeEqualFold))
	}
	if i.PostalCodeContainsFold != nil {
		predicates = append(predicates, person.PostalCodeContainsFold(*i.PostalCodeContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, person.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, person.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, person.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, person.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, person.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, person.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, person.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, person.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, person.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, person.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, person.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityIsNil {
		predicates = append(predicates, person.CityIsNil())
	}
	if i.CityNotNil {
		predicates = append(predicates, person.CityNotNil())
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, person.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, person.CityContainsFold(*i.CityContainsFold))
	}
	if i.Country != nil {
		predicates = append(predicates, person.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, person.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, person.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, person.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, person.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, person.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, person.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, person.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, person.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, person.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, person.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryIsNil {
		predicates = append(predicates, person.CountryIsNil())
	}
	if i.CountryNotNil {
		predicates = append(predicates, person.CountryNotNil())
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, person.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, person.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.Subscribed != nil {
		predicates = append(predicates, person.SubscribedEQ(*i.Subscribed))
	}
	if i.SubscribedNEQ != nil {
		predicates = append(predicates, person.SubscribedNEQ(*i.SubscribedNEQ))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, person.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, person.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, person.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, person.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, person.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, person.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, person.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, person.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, person.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, person.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, person.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, person.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, person.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, person.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, person.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, person.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasAuthentications != nil {
		p := person.HasAuthentications()
		if !*i.HasAuthentications {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthenticationsWith) > 0 {
		with := make([]predicate.Authentication, 0, len(i.HasAuthenticationsWith))
		for _, w := range i.HasAuthenticationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuthenticationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasAuthenticationsWith(with...))
	}
	if i.HasAuthorizations != nil {
		p := person.HasAuthorizations()
		if !*i.HasAuthorizations {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthorizationsWith) > 0 {
		with := make([]predicate.Authorization, 0, len(i.HasAuthorizationsWith))
		for _, w := range i.HasAuthorizationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuthorizationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasAuthorizationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPersonWhereInput
	case 1:
		return predicates[0], nil
	default:
		return person.And(predicates...), nil
	}
}
